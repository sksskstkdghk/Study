#include "Client.h"

Client::Client()
{
}

Client::~Client()
{
}

void Client::Init()
{
	clientHeart = true;

	WSAStartup(MAKEWORD(2, 2), &wsaData);

	//clientSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
	clientSock = WSASocket(PF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);

	clientAddr.sin_family = AF_INET;
	clientAddr.sin_port = htons(PORT);
	clientAddr.sin_addr.s_addr = inet_addr(SERVER_IP);

	connect(clientSock, (SOCKADDR*)&clientAddr, sizeof(clientAddr));

	dwError = 0;
	recvBytes = sendBytes = 0;

	cEvent = WSACreateEvent();
	//WSAEventSelect(clientSock, cEvent, FD_READ | FD_CLOSE);
	if (WSASetEvent(cEvent))
	{
		cout << "WSASetEvent 성공" << endl;
	}
	else
	{
		cout << "WSASetEvent 실패" << endl;
		exit(0);
	}
	overlapped.hEvent = cEvent;

	ZeroMemory(cBuffer, PACKET_SIZE);
	send(clientSock, cBuffer, strlen(cBuffer), 0);

	cout << "닉네임 설정: ";
	cin >> cBuffer;

	send(clientSock, cBuffer, strlen(cBuffer), 0);
	//WSASend(clientSock, &dataBuf, 1, &sendBytes, flag, &overlapped, NULL);

	//tcpkl.onoff = 1;
	//tcpkl.keepalivetime = 5000;	//1초 마다 신호를 보내겠다
	//tcpkl.keepaliveinterval = 5000; //신호를 보낸 후 응답이 없다면 1초마다 재 전송 하겠다.

	//WSAIoctl(clientSock, SIO_KEEPALIVE_VALS, &tcpkl,
	//	sizeof(tcp_keepalive), 0, 0, &dwError, NULL, NULL);
}

void Client::SendMsg()
{
	while (clientHeart)
	{
		ZeroMemory(cBuffer, PACKET_SIZE);
		
		cin.getline(cBuffer, PACKET_SIZE);

		if (strcmp(cBuffer, "exit") == 0)
		{
			clientHeart = false;
			continue;
		}

		//클라가 서버에게 정보를 보내거나 서버가 클라에게 데이터를 보내는 함수
		//엄밀히 따지자면 해당 소켓에게 데이터를 전달하는 함수
		send(clientSock, cBuffer, strlen(cBuffer), 0);
	}
}

void Client::GetMsg()
{
	while (clientHeart)
	{
		ZeroMemory(sBuffer, PACKET_SIZE);

		recv(clientSock, sBuffer, strlen(sBuffer), NULL);

		cout << sBuffer << endl;

		/*if (WSARecv(clientSock, &dataBuf, 1, &recvBytes, &flag, &overlapped, NULL) == SOCKET_ERROR)
		{
			dwError = WSAGetLastError();

			if (dwError == WSA_IO_PENDING)
			{
				WSAWaitForMultipleEvents(1, &cEvent, TRUE, WSA_INFINITE, FALSE);

				if (WSAGetOverlappedResult(clientSock, &overlapped, &recvBytes, FALSE, &flag))
				{

				}
			}
			else if (dwError == WSAECONNABORTED)
			{
				cout << "서버가 종료되어 클라이언트를 종료합니다" << endl;

				break;
			}
		}*/
		
		//int isError = WSAEnumNetworkEvents(clientSock, cEvent, &netEvent);

		//if (isError == SOCKET_ERROR)
		//{
		//	cout << WSAGetLastError() << endl;

		//	continue;
		//}

		//if (netEvent.lNetworkEvents == FD_READ)
		//{
		//	//대상 소켓으로부터 보내온 정보를 받아주는 함수
		//	//받아오기전까지 해당 위치에서 프로그램이 멈춘다
		//	//recv(clientSock, sBuffer, PACKET_SIZE, 0);
		//	

		//	cout << sBuffer << endl;
		//}
		//else if (netEvent.lNetworkEvents == FD_CLOSE)
		//{
		//	cout << "서버가 종료되어 클라이언트를 종료합니다" << endl;

		//	break;
		//}
	}
}

void Client::Close()
{
	closesocket(clientSock);
	WSACloseEvent(cEvent);

	WSACleanup();
}
